
/*
 * ! @chakra-ui/vue v0.10.2 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('./index-a67b3d6b.js');
require('./index-1b221f99.js');
require('@emotion/css');
require('vue');
require('./color-mode-observer-fffa3a3b.js');
var CBox = require('./CBox.js');
var props_types = require('./props.types-b9d2d3c4.js');
var CFlex = require('./index-eb2552c9.js');

/**
 * Hey! Welcome to @chakra-ui/vue Stack
 *
 * Stack is a layout utility component that makes
 * it easy to stack elements together and apply a space between them.
 *
 * @see Docs     https://vue.chakra-ui.com/stack
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CStack/CStack.js
 */
/**
 * CStack component
 *
 * Flex container to stck it's children
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/stack
 */

var CStack = {
  name: 'CStack',
  mixins: [utils.createStyledAttrsMixin('CStack')],
  props: {
    direction: [String, Array],
    isInline: {
      type: Boolean,
      default: false
    },
    isReversed: {
      type: Boolean,
      default: false
    },
    align: props_types.StringArray,
    justify: props_types.StringArray,
    spacing: {
      type: props_types.SNA,
      default: 2
    },
    shouldWrapChildren: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    _isInline: function _isInline() {
      return this.isInline || this.direction && this.direction.startsWith('row');
    },
    _isReversed: function _isReversed() {
      return this.isReversed || this.direction && this.direction.endsWith('reverse');
    },
    _direction: function _direction() {
      var _direction;

      if (this._isInline) {
        _direction = 'row';
      }

      if (this._isReversed) {
        _direction = this.isInline ? 'row-reverse' : 'column-reverse';
      }

      if (this.direction) {
        _direction = this.direction;
      }

      if (!this._isInline && !this._isReversed && !this.direction) {
        _direction = 'column';
      }

      return _direction;
    }
  },
  render: function render(h) {
    var this$1 = this;
    var defaultSlot = this.$slots.default || [];
    var children = defaultSlot.filter(function (e) {
      return e.tag;
    });
    var stackables = children.map(function (node, index) {
      var obj, obj$1;
      var isLastChild = children.length === index + 1;
      var spacingProps = this$1._isInline ? (obj = {}, obj[this$1._isReversed ? 'ml' : 'mr'] = isLastChild ? null : this$1.spacing, obj) : (obj$1 = {}, obj$1[this$1._isReversed ? 'mt' : 'mb'] = isLastChild ? null : this$1.spacing, obj$1);
      var clone = utils.cloneVNode(node, h);

      if (!clone.componentOptions) {
        clone = h(CBox.default, [clone]);
      }

      var ref = clone.componentOptions;
      var propsData = ref.propsData;
      var ref$1 = clone.data;
      var attrs = ref$1.attrs; // If children nodes should wrap,
      // we wrap them inside block with
      // display set to inline block.

      if (this$1.shouldWrapChildren) {
        return h(CBox.default, {
          props: {
            as: this$1.as,
            to: this$1.to
          },
          attrs: Object.assign({}, {
            d: 'inline-block'
          }, spacingProps)
        }, [clone]);
      } // Otherwise we simply set spacing props
      // to current node.


      clone.componentOptions.propsData = Object.assign({}, propsData);
      clone.data.attrs = Object.assign({}, attrs, spacingProps);
      return clone;
    });
    return h(CFlex.CFlex, {
      class: this.className,
      props: {
        as: this.as,
        align: this.align,
        justify: this.justify,
        direction: this._direction
      },
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, stackables);
  }
};

exports.default = CStack;
