
/*
 * ! @chakra-ui/vue v0.10.2 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

'use strict';

var utils = require('./index-a67b3d6b.js');
var CPseudoBox = require('./CPseudoBox.js');
var CButton = require('./index-62637255.js');
var CDivider = require('./CDivider.js');
var CText = require('./CText.js');
var CFragment = require('./CFragment.js');
var CPopper = require('./CPopper.js');

/**
 * Base style props for menu list items
 */
var baseProps = {
  width: 'full',
  flex: ' 0 0 auto',
  userSelect: 'none',
  transition: 'background-color 220ms, color 220ms'
};
/**
 * Gets menu components list styles object
 * @param {String} colorMode Color mode
 * @returns {Object} Styles object
 */

var useMenuListStyle = function useMenuListStyle(colorMode) {
  var elevation = {
    light: {
      bg: '#fff',
      shadow: 'sm'
    },
    dark: {
      bg: 'gray.700',
      shadow: 'rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px'
    }
  };
  return Object.assign({}, {
    color: 'inherit',
    borderColor: 'gray.200',
    borderWidth: '1px'
  }, elevation[colorMode]);
};
/**
 * Gets interaction style props
 * @param {Object} param0 props
 */

var interactionProps = function interactionProps(ref) {
  var colorMode = ref.colorMode;
  var _focusColor = {
    light: 'gray.100',
    dark: 'whiteAlpha.100'
  };
  var _activeColor = {
    light: 'gray.200',
    dark: 'whiteAlpha.200'
  };
  return {
    _active: {
      bg: _activeColor[colorMode]
    },
    _focus: {
      bg: _focusColor[colorMode],
      outline: 0
    },
    _disabled: {
      opacity: 0.4,
      cursor: 'not-allowed'
    }
  };
};
/**
 * Gets menu list item styles
 * @param {{theme: Object, colorMode: String }} props Options
 */


var useMenuItemStyle = function useMenuItemStyle(ref) {
  var theme = ref.theme;
  var colorMode = ref.colorMode;
  var props = {
    theme: theme,
    colorMode: colorMode
  };
  return Object.assign({}, baseProps, interactionProps(props));
};

/**
 * Hey! Welcome to @chakra-ui/vue Menu
 *
 * `CMenu` is An accessible dropdown menu for the common dropdown menu button design pattern.
 *
 * @see Docs     https://vue.chakra-ui.com/menu
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CMenu/CMenu.js
 */
function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
var menuProps = {
  controlledIsOpen: Boolean,
  isControlled: Boolean,
  defaultIsOpen: Boolean,
  onOpen: Function,
  onClose: Function,
  autoSelect: {
    type: Boolean,
    default: true
  },
  closeOnBlur: {
    type: Boolean,
    default: true
  },
  closeOnSelect: {
    type: Boolean,
    default: true
  },
  defaultActiveIndex: Number,
  placement: String
};
/**
 * CMenu component
 *
 * The menu container element
 *
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenu = {
  name: 'CMenu',
  inject: ['$chakraColorMode', '$chakraTheme'],
  provide: function provide() {
    var this$1 = this;
    return {
      $MenuContext: function $MenuContext() {
        return this$1.MenuContext;
      }
    };
  },
  props: menuProps,
  data: function data() {
    return {
      isOpen: this.isControlled ? this.controlledIsOpen : this.defaultIsOpen || false,
      activeIndex: this.defaultActiveIndex || -1,
      focusableItems: null,
      menuNode: undefined,
      buttonNode: undefined,
      prevIsOpen: undefined
    };
  },
  computed: {
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    theme: function theme() {
      return this.$chakraTheme();
    },
    menuId: function menuId() {
      return "menu-" + utils.useId();
    },
    buttonId: function buttonId() {
      return "menubutton-" + utils.useId();
    },
    MenuContext: function MenuContext() {
      return {
        activeIndex: this.activeIndex,
        isOpen: this.isOpen,
        menuNode: this.menuNode,
        buttonNode: this.buttonNode,
        focusableItems: this.focusableItems,
        placement: this.placement,
        menuId: this.menuId,
        buttonId: this.buttonId,
        colorMode: this.colorMode,
        focusAtIndex: this.focusAtIndex,
        focusOnLastItem: this.focusOnLastItem,
        focusOnFirstItem: this.focusOnFirstItem,
        closeMenu: this.closeMenu,
        autoSelect: this.autoSelect,
        closeOnSelect: this.closeOnSelect,
        closeOnBlur: this.closeOnBlur
      };
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    var menuNode;
    var buttonNode;
    this.$nextTick(function () {
      // In child components bind menuId to menuNode and bind it
      menuNode = utils.canUseDOM && document.querySelector("#" + this$1.menuId);
      this$1.menuNode = menuNode;
      buttonNode = utils.canUseDOM && document.querySelector("#" + this$1.buttonId);
      this$1.buttonNode = buttonNode;
    });
    this.$watch('isOpen', function (_newVal, oldVal) {
      this$1.prevIsOpen = oldVal;
    }, {
      immediate: true
    });
    this.$watch('isOpen', function (isOpen) {
      if (isOpen && menuNode) {
        var focusables = utils.getFocusables(menuNode).filter(function (node) {
          return ['menuitem', 'menuitemradio', 'menuitemcheckbox'].includes(node.getAttribute('role'));
        });
        this$1.focusableItems = menuNode ? focusables : [];
        this$1.initTabIndex();
      }
    });
    this.$watch(function (vm) {
      return [vm.activeIndex, vm.isOpen, vm.menuNode, vm.buttonNode];
    }, function () {
      if (this$1.activeIndex !== -1) {
        this$1.focusableItems[this$1.activeIndex] && this$1.focusableItems[this$1.activeIndex].focus();
        this$1.updateTabIndex(this$1.activeIndex);
      }

      if (this$1.activeIndex === -1 && !this$1.isOpen && this$1.prevIsOpen) {
        this$1.buttonNode && this$1.buttonNode.focus();
      }

      if (this$1.activeIndex === -1 && this$1.isOpen) {
        this$1.menuNode && this$1.menuNode.focus();
      }
    });
  },
  methods: {
    /**
     * Initializes tab indexing on menu list items
     */
    initTabIndex: function initTabIndex() {
      this.focusableItems.forEach(function (node, index) {
        return index === 0 && node.setAttribute('tabindex', 0);
      });
    },

    /**
     * Updates tab index for menulist items
     * @param {Number} index Position index of menu list item
     */
    updateTabIndex: function updateTabIndex(index) {
      if (this.focusableItems.length > 0) {
        var nodeAtIndex = this.focusableItems[index];
        this.focusableItems.forEach(function (node) {
          if (node !== nodeAtIndex) {
            node.setAttribute('tabindex', -1);
          }
        });
        nodeAtIndex.setAttribute('tabindex', 0);
      }
    },

    /**
     * Resets tab index of menu list items
     */
    resetTabIndex: function resetTabIndex() {
      if (this.focusableItems) {
        this.focusableItems.forEach(function (node) {
          return node.setAttribute('tabindex', -1);
        });
      }
    },

    /**
     * Opens Menu component
     */
    openMenu: function openMenu() {
      if (!this.isControlled) {
        this.isOpen = true;
      }

      if (this.onOpen) {
        this.onOpen();
      }
    },

    /**
     * Focuses first menulist element.
     */
    focusOnFirstItem: function focusOnFirstItem() {
      this.openMenu();
      this.activeIndex = 0;
    },

    /**
     * Focuses an element at a particular index
     * @param {Number} index Menulist items index
     */
    focusAtIndex: function focusAtIndex(index) {
      this.activeIndex = index;
    },

    /**
     * Focuses last menulist item
     */
    focusOnLastItem: function focusOnLastItem() {
      this.openMenu();
      this.activeIndex = this.focusableItems.length - 1;
    },

    /**
     * Closes Menu
     */
    closeMenu: function closeMenu() {
      if (!this.isControlled) {
        this.isOpen = false;
      }

      if (this.onClose) {
        this.onClose();
      }

      this.activeIndex = -1;
      this.resetTabIndex();
    }
  },
  render: function render(h) {
    return h(CFragment.default, {
      attrs: {
        'data-chakra-component': 'CMenu'
      }
    }, [this.$scopedSlots.default({
      isOpen: this.isOpen
    })]);
  }
};
/**
 * CMenuButton component
 *
 * The menu button element
 *
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenuButton = {
  name: 'CMenuButton',
  inheritAttrs: false,
  inject: ['$MenuContext'],
  props: CButton.buttonProps,
  computed: {
    context: function context() {
      return this.$MenuContext();
    }
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var isOpen = ref.isOpen;
    var buttonId = ref.buttonId;
    var menuId = ref.menuId;
    var closeMenu = ref.closeMenu;
    var autoSelect = ref.autoSelect;
    var focusOnFirstItem = ref.focusOnFirstItem;
    var focusOnLastItem = ref.focusOnLastItem;
    var openMenu = ref.openMenu;
    return h(CButton.CButton, {
      props: Object.assign({}, utils.pickProperty(this.$props), {
        isLoading: false
      }),
      attrs: Object.assign({}, {
        id: buttonId,
        role: 'button',
        'aria-haspopup': 'menu',
        'aria-expanded': isOpen,
        'aria-controls': menuId,
        'data-chakra-component': 'CMenuButton'
      }, this.$attrs),
      nativeOn: {
        click: function click(event) {
          this$1.$emit('click', event);

          if (isOpen) {
            closeMenu();
          } else if (autoSelect) {
            focusOnFirstItem();
          } else {
            openMenu();
          }
        },
        keydown: function keydown(event) {
          if (event.key === 'ArrowDown') {
            event.preventDefault();
            focusOnFirstItem();
          }

          if (event.key === 'ArrowUp') {
            event.preventDefault();
            focusOnLastItem();
          }
        }
      }
    }, this.$slots.default);
  }
};
/**
 * CMenuList component
 *
 * The menu list element
 *
 * @extends CPopper
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenuList = {
  name: 'CMenuList',
  inheritAttrs: false,
  inject: ['$MenuContext', '$chakraColorMode'],
  computed: {
    context: function context() {
      return this.$MenuContext();
    },
    menuListStyles: function menuListStyles() {
      return function (colorMode) {
        return useMenuListStyle(colorMode);
      };
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    }
  },
  props: {
    placement: {
      type: String,
      validator: function validator(value) {
        return value.match(/^(top|top-start|top-end|right|right-start|right-end|bottom|bottom-start|bottom-end|left|left-start|left-end)$/);
      }
    }
  },
  methods: {
    handleKeyDown: function handleKeyDown(event) {
      var ref = this.context;
      var index = ref.activeIndex;
      var focusAtIndex = ref.focusAtIndex;
      var focusOnFirstItem = ref.focusOnFirstItem;
      var focusOnLastItem = ref.focusOnLastItem;
      var closeMenu = ref.closeMenu;
      var focusableItems = ref.focusableItems;
      var count = focusableItems.length;
      var nextIndex;

      if (event.key === 'ArrowDown') {
        event.preventDefault();
        nextIndex = (index + 1) % count;
        focusAtIndex(nextIndex);
      } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        nextIndex = (index - 1 + count) % count;
        focusAtIndex(nextIndex);
      } else if (event.key === 'Home') {
        focusOnFirstItem();
      } else if (event.key === 'End') {
        focusOnLastItem();
      } else if (event.key === 'Tab') {
        event.preventDefault();
      } else if (event.key === 'Escape') {
        closeMenu();
      } // Set focus based on first character


      if (/^[a-z0-9_-]$/i.test(event.key)) {
        event.stopPropagation();
        event.preventDefault();
        var foundNode = focusableItems.find(function (item) {
          return item.textContent.toLowerCase().startsWith(event.key);
        });

        if (foundNode) {
          nextIndex = focusableItems.indexOf(foundNode);
          focusAtIndex(nextIndex);
        }
      }

      this.$emit('keydown', event);
    },
    handleBlur: function handleBlur(event) {
      var ref = this.context;
      var menuNode = ref.menuNode;
      var buttonNode = ref.buttonNode;
      var isOpen = ref.isOpen;
      var closeOnBlur = ref.closeOnBlur;
      var closeMenu = ref.closeMenu;

      if (closeOnBlur && isOpen && menuNode && buttonNode && !menuNode.contains(event.relatedTarget) && !buttonNode.contains(event.relatedTarget)) {
        closeMenu();
      }

      this.$emit('blur', event);
    }
  },
  render: function render(h) {
    var ref = this.context;
    var isOpen = ref.isOpen;
    var buttonNode = ref.buttonNode;
    var menuId = ref.menuId;
    var buttonId = ref.buttonId;
    var placement = ref.placement;
    var closeMenu = ref.closeMenu;
    var closeOnBlur = ref.closeOnBlur;
    return h(CPopper.CPopper, {
      props: {
        usePortal: false,
        isOpen: isOpen,
        anchorEl: buttonNode,
        placement: this.placement || placement,
        modifiers: [{
          name: 'preventOverflow',
          options: {
            rootBoundary: 'viewport'
          }
        }],
        closeOnClickAway: closeOnBlur,
        hasArrow: false
      },
      attrs: Object.assign({}, {
        minW: '3xs',
        rounded: 'md',
        py: 2,
        'z-index': 1,
        _focus: {
          outline: 0
        }
      }, this.menuListStyles(this.colorMode), this.$attrs, {
        id: menuId,
        role: 'menu',
        'aria-labelledby': buttonId,
        tabindex: -1,
        'data-chakra-component': 'CMenuButton'
      }),
      on: {
        close: closeMenu
      },
      nativeOn: {
        keydown: this.handleKeyDown,
        blur: this.handleBlur
      }
    }, this.$slots.default);
  }
};
/**
 * CMenuItem component
 *
 * The menu list item element
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenuItem = {
  name: 'CMenuItem',
  inheritAttrs: false,
  inject: ['$MenuContext', '$chakraTheme', '$chakraColorMode'],
  props: {
    isDisabled: Boolean,
    role: {
      type: String,
      default: 'menuitem'
    },
    as: {
      type: [String, Object],
      default: 'button'
    }
  },
  computed: {
    context: function context() {
      return this.$MenuContext();
    },
    menuItemStyles: function menuItemStyles() {
      return function (props) {
        return useMenuItemStyle(props);
      };
    },
    theme: function theme() {
      return this.$chakraTheme();
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    }
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var focusableItems = ref.focusableItems;
    var focusAtIndex = ref.focusAtIndex;
    var closeOnSelect = ref.closeOnSelect;
    var closeMenu = ref.closeMenu;
    return h(CPseudoBox.default, {
      props: {
        as: this.as
      },
      attrs: Object.assign({}, {
        display: 'flex',
        textDecoration: 'none',
        color: 'inherit',
        minHeight: '32px',
        alignItems: 'center',
        textAlign: 'left',
        outline: 'none',
        px: 4
      }, this.menuItemStyles({
        theme: this.theme,
        colorMode: this.colorMode
      }), this.$attrs, {
        role: this.role,
        tabindex: -1,
        disabled: this.isDisabled,
        'aria-disabled': this.isDisabled,
        'data-chakra-component': 'CMenuItem'
      }),
      nativeOn: {
        click: function click(event) {
          this$1.$emit('click', event);

          if (this$1.isDisabled) {
            event.stopPropagation();
            event.preventDefault();
            return;
          }

          if (closeOnSelect) {
            closeMenu();
          }
        },
        mouseenter: function mouseenter(event) {
          this$1.$emit('mouseenter', event);

          if (this$1.isDisabled) {
            event.stopPropagation();
            event.preventDefault();
            return;
          }

          if (focusableItems && focusableItems.length > 0) {
            var nextIndex = focusableItems.indexOf(event.currentTarget);
            focusAtIndex(nextIndex);
          }
        },
        mouseleave: function mouseleave() {
          focusAtIndex(-1);
        },
        keydown: function keydown(event) {
          this$1.$emit('keydown', event);

          if (this$1.isDisabled) {
            return;
          }

          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault(); // We also emit click event to simulate click event for keyboard "Enter" keydown event

            this$1.$emit('click');

            if (closeOnSelect) {
              closeMenu();
            }
          }
        }
      }
    }, this.$slots.default);
  }
};
/**
 * CMenuDivider component
 *
 * The menu list divider element
 *
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenuDivider = {
  name: 'CMenuDivider',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["data"]);
    var rest = rest$1;
    return h(CDivider.default, Object.assign({}, rest, {
      attrs: Object.assign({}, {
        marginTop: '0.5rem',
        marginBottom: '0.5rem'
      }, data.attrs, {
        'data-chakra-component': 'CMenuDivider'
      })
    }));
  }
};
/**
 * CMenuGroup component
 *
 * The menu list item group.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/menu
 */

var CMenuGroup = {
  name: 'CMenuGroup',
  functional: true,
  props: {
    title: String
  },
  render: function render(h, ref) {
    var props = ref.props;
    var slots = ref.slots;
    var data = ref.data;
    return h('div', {
      attrs: {
        role: 'group',
        'data-chakra-component': 'CMenuGroup'
      }
    }, [props.title && h(CText.default, {
      attrs: Object.assign({}, {
        mx: 4,
        my: 2,
        fontWeight: 'semibold',
        fontSize: 'sm'
      }, data.attrs)
    }, props.title), slots().default]);
  }
};

exports.CMenu = CMenu;
exports.CMenuButton = CMenuButton;
exports.CMenuDivider = CMenuDivider;
exports.CMenuGroup = CMenuGroup;
exports.CMenuItem = CMenuItem;
exports.CMenuList = CMenuList;
exports.useMenuItemStyle = useMenuItemStyle;
