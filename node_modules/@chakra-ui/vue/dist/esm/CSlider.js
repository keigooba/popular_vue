
/*
 * ! @chakra-ui/vue v0.10.2 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

import { R as createStyledAttrsMixin, M as isDef, v as valueToPercent, J as useId, x as getElById, a0 as percentToValue } from './index-88b4bf19.js';
import './index-980f0b61.js';
import '@emotion/css';
import 'vue';
import './color-mode-observer-5bf3a66d.js';

var centeredProps = {
  position: 'absolute',
  top: '50%',
  transform: 'translateY(-50%)'
};

var thumbStyle = function thumbStyle(ref) {
  var thumbSize = ref.thumbSize;
  var trackPercent = ref.trackPercent;
  var theme = ref.theme;
  return Object.assign({}, centeredProps, {
    zIndex: 1,
    width: thumbSize,
    height: thumbSize,
    rounded: 'full',
    bg: '#fff',
    shadow: 'sm',
    left: "calc(" + trackPercent + "% - " + thumbSize + " / 2)",
    border: '1px',
    borderColor: 'transparent',
    // TODO: Find another more performant way to implement the slider transitions
    // We could use the CSS "will-change: width;" property. So for now, abrupt transitions :D
    // transition: 'width 0.3s cubic-bezier(0.25, 0.8, 0.5, 1)'
    _focus: {
      shadow: 'outline'
    },
    _disabled: {
      backgroundColor: 'gray.300'
    },
    _active: {
      transform: 'translateY(-50%) scale(1.15)'
    }
  });
};

var filledTrackStyle = function filledTrackStyle(ref) {
  var trackHeight = ref.trackHeight;
  var trackPercent = ref.trackPercent;
  var color = ref.color;
  var colorMode = ref.colorMode;
  return Object.assign({}, centeredProps, {
    height: trackHeight,
    bg: colorMode === 'light' ? color + ".500" : color + ".200",
    width: trackPercent + "%",
    rounded: 'sm'
  });
};

var themedTrackStyle = {
  light: {
    bg: 'gray.200',
    _disabled: {
      bg: 'gray.300'
    }
  },
  dark: {
    bg: 'whiteAlpha.200',
    _disabled: {
      bg: 'whiteAlpha.300'
    }
  }
};

var trackStyle = function trackStyle(ref) {
  var trackHeight = ref.trackHeight;
  var theme = ref.theme;
  var colorMode = ref.colorMode;
  return Object.assign({}, {
    height: trackHeight,
    borderRadius: 'sm',
    width: '100%'
  }, centeredProps, themedTrackStyle[colorMode]);
};

var rootStyle = {
  width: 'full',
  display: 'inline-block',
  position: 'relative',
  cursor: 'pointer',
  _disabled: {
    opacity: 0.6,
    cursor: 'default',
    pointerEvents: 'none'
  }
};
var sizes = {
  lg: {
    thumb: '16px',
    trackHeight: '4px'
  },
  md: {
    thumb: '14px',
    trackHeight: '4px'
  },
  sm: {
    thumb: '10px',
    trackHeight: '2px'
  }
};
/**
 * Generates slider style props
 * @param {{theme: Object, colorMode: String, trackPercent: String, size: String, color: String}} props Style props
 * @returns {Object} Slider styles
 */

var useSliderStyle = function useSliderStyle(props) {
  var theme = props.theme;
  var colorMode = props.colorMode;
  var trackPercent = props.trackPercent;
  var size = props.size;
  var color = props.color;
  var ref = sizes[size];
  var trackHeight = ref.trackHeight;
  var thumbSize = ref.thumb;
  var _props = {
    trackHeight: trackHeight,
    thumbSize: thumbSize,
    theme: theme,
    trackPercent: trackPercent,
    color: color,
    colorMode: colorMode
  };
  return {
    rootStyle: rootStyle,
    trackStyle: trackStyle(_props),
    filledTrackStyle: filledTrackStyle(_props),
    thumbStyle: thumbStyle(_props)
  };
};

/**
 * Conforms a value to provided precision
 * @param {Value} value Value
 * @param {Number} step step
 * @returns {Number} Precise value
 */
function makeValuePrecise(value, step) {
  var stepDecimalPart = step.toString().split('.')[1];
  var stepPrecision = stepDecimalPart ? stepDecimalPart.length : 0;
  return Number(value.toFixed(stepPrecision));
}
/**
 * Rounds off a value to the nearest step
 * @param {Number} value Value
 * @param {Number} step step
 * @returns {Number} rounded value
 */


function roundValueToStep(value, step) {
  return makeValuePrecise(Math.round(value / step) * step, step);
}
/**
 * Clamps provided value within domain
 * @param {Number} val Value
 * @param {Number} min Minimum value
 * @param {Number} max Maximum value
 * @returns {Number} clamped value
 */

function clampValue(val, min, max) {
  if (val > max) {
    return max;
  }

  if (val < min) {
    return min;
  }

  return val;
}

/**
 * Hey! Welcome to @chakra-ui/vue CSlider
 *
 * The Slider is used to allow users to make
 * selections from a range of values.
 *
 * @see Docs     https://vue.chakra-ui.com/slider
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CSlider/CSlider.js
 */
/**
 * CSlider component
 *
 * The Slider wrapper component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/slider
 */

var CSlider = {
  name: 'CSlider',
  mixins: [createStyledAttrsMixin('CSlider')],
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    value: Number,
    defaultValue: Number,
    isDisabled: Boolean,
    max: {
      type: Number,
      default: 100
    },
    min: {
      type: Number,
      default: 0
    },
    step: {
      type: Number,
      default: 1
    },
    ariaLabel: String,
    ariaLabelledBy: String,
    ariaValueText: String,
    orientation: {
      type: String,
      default: 'horizontal'
    },
    getAriaValueText: Function,
    size: {
      type: String,
      default: 'md'
    },
    color: {
      type: String,
      default: 'blue'
    },
    name: String,
    id: String
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $SliderContext: function $SliderContext() {
        return this$1.SliderContext;
      }
    };
  },
  data: function data() {
    return {
      innerValue: this.defaultValue || 0,
      trackNode: undefined,
      thumbNode: undefined
    };
  },
  computed: {
    isControlled: function isControlled() {
      return isDef(this.value);
    },
    _value: function _value() {
      return this.isControlled ? this.value : this.innerValue;
    },
    actualValue: function actualValue() {
      return clampValue(this._value, this.min, this.max);
    },
    trackPercentage: function trackPercentage() {
      return valueToPercent(this.actualValue, this.min, this.max);
    },
    theme: function theme() {
      return this.$chakraTheme();
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    _id: function _id() {
      return this.id || useId();
    },
    trackId: function trackId() {
      return "slider-track-" + this._id;
    },
    thumbId: function thumbId() {
      return "slider-thumb-" + this._id;
    },
    sliderStyles: function sliderStyles() {
      var ref = useSliderStyle({
        color: this.color,
        colorMode: this.colorMode,
        size: this.size,
        theme: this.theme,
        trackPercent: this.trackPercentage
      });
      var rootStyle = ref.rootStyle;
      return rootStyle;
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, this.sliderStyles, {
        py: 3
      });
    },
    valueText: function valueText() {
      return this.getAriaValueText ? this.getAriaValueText(this.actualValue) : this.ariaValueText;
    },
    SliderContext: function SliderContext() {
      var this$1 = this;
      return {
        trackNode: this.trackNode,
        thumbNode: this.thumbNode,
        onThumbKeyDown: this.handleThumbKeyDown,
        onFocus: function onFocus(e) {
          return this$1.$emit('focus', e);
        },
        trackPercent: this.trackPercentage,
        ariaLabelledBy: this.ariaLabelledBy,
        orientation: this.orientation,
        isDisabled: this.isDisabled,
        size: this.size,
        color: this.color,
        min: this.min,
        max: this.max,
        valueText: this.valueText,
        value: this.actualValue,
        trackId: this.trackId,
        thumbId: this.thumbId
      };
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$nextTick(function () {
      this$1.trackNode = getElById(this$1.trackId);
      this$1.thumbNode = getElById(this$1.thumbId);
    });
  },
  methods: {
    /**
     * Parses new value returned from slider change event
     * @param {Event} event
     */
    getNewValue: function getNewValue(event) {
      if (this.trackNode) {
        var ref = this.trackNode.getBoundingClientRect();
        var left = ref.left;
        var width = ref.width;
        var ref$1 = event.touches ? event.touches[0] : event;
        var clientX = ref$1.clientX;
        var diffX = clientX - left;
        var percent = diffX / width;
        var newValue = percentToValue(percent, this.min, this.max);

        if (this.step) {
          newValue = roundValueToStep(newValue, this.step);
        }

        newValue = clampValue(newValue, this.min, this.max);
        return newValue;
      }
    },

    /**
     * Updates current inner value
     * @param {Number} newValue New Value
     */
    updateValue: function updateValue(newValue) {
      if (!this.isControlled) {
        this.innerValue = newValue;
      }

      this.$emit('change', newValue);
    },

    /**
     * Handles SliderThumb keydown event
     * @param {Event} event
     */
    handleThumbKeyDown: function handleThumbKeyDown(event) {
      var flag = false;
      var newValue;
      var tenSteps = (this.max - this.min) / 10;

      switch (event.key) {
        case 'ArrowLeft':
        case 'ArrowDown':
          newValue = this.actualValue - this.step;
          flag = true;
          break;

        case 'ArrowRight':
        case 'ArrowUp':
          newValue = this.actualValue + this.step;
          flag = true;
          break;

        case 'PageDown':
          newValue = this.actualValue - tenSteps;
          flag = true;
          break;

        case 'PageUp':
          newValue = this.actualValue + tenSteps;
          flag = true;
          break;

        case 'Home':
          newValue = this.min;
          flag = true;
          break;

        case 'End':
          newValue = this.max;
          flag = true;
          break;

        default:
          return;
      }

      if (flag) {
        event.preventDefault();
        event.stopPropagation();
      }

      if (this.step) {
        newValue = roundValueToStep(newValue, this.step);
      }

      newValue = clampValue(newValue, this.min, this.max);
      this.updateValue(newValue);
      this.$emit('keydown', event);
    },

    /**
     * Handle sliderthumb mouseup event
     */
    handleMouseUp: function handleMouseUp() {
      document.body.removeEventListener('mousemove', this.handleMouseMove);
      document.body.removeEventListener('touchmove', this.handleMouseMove);
      document.body.removeEventListener('mouseup', this.handleMouseUp);
      document.body.removeEventListener('touchend', this.handleMouseUp);
    },

    /**
     * Handles mousedown event for slider
     * @param {Event} event
     */
    handleMouseDown: function handleMouseDown(event) {
      if (this.isDisabled) {
        return;
      }

      this.$emit('mousedown', event);
      event.preventDefault();
      var newValue = this.getNewValue(event);

      if (newValue !== this.actualValue) {
        this.updateValue(newValue);
      }

      document.body.addEventListener('mousemove', this.handleMouseMove);
      document.body.addEventListener('touchmove', this.handleMouseMove);
      document.body.addEventListener('mouseup', this.handleMouseUp);
      document.body.addEventListener('touchend', this.handleMouseUp);
      this.thumbNode && this.thumbNode.focus();
    },

    /**
     * Handles slider thumb mousemove event
     * @param {Event} event
     */
    handleMouseMove: function handleMouseMove(event) {
      var newValue = this.getNewValue(event);
      this.updateValue(newValue);
    }
  },
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default || [];
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        role: 'presentation',
        'aria-disabled': this.isDisabled
      }, this.computedAttrs),
      style: {
        touchAction: 'none'
      },
      on: Object.assign({}, this.computedListeners, {
        mousedown: this.handleMouseDown,
        touchstart: this.handleMouseDown,
        mouseleave: this.handleMouseUp,
        touchend: this.handleMouseUp,
        blur: function blur(event) {
          this$1.handleMouseUp(event);
          this$1.$emit('blur', event);
        }
      })
    }, children.concat([h('input', {
      attrs: {
        type: 'hidden',
        value: this.actualValue,
        name: this.name,
        id: this._id
      }
    })]));
  }
};
/**
 * CSliderTrack component
 *
 * The track for the slider component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/slider
 */

var CSliderTrack = {
  name: 'CSliderTrack',
  mixins: [createStyledAttrsMixin('CSliderTrack')],
  inject: ['$SliderContext'],
  computed: {
    context: function context() {
      return this.$SliderContext();
    },
    componentStyles: function componentStyles() {
      var ref = useSliderStyle(Object.assign({}, this.context, {
        theme: this.theme,
        colorMode: this.colorMode
      }));
      var trackStyle = ref.trackStyle;
      return trackStyle;
    }
  },
  render: function render(h) {
    var ref = this.context;
    var isDisabled = ref.isDisabled;
    var trackId = ref.trackId;
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        id: trackId,
        'data-slider-track': '',
        'aria-disabled': isDisabled
      }),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CSliderFilledTrack component
 *
 * The track filler for the slider component
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/slider
 */

var CSliderFilledTrack = {
  name: 'CSliderFilledTrack',
  mixins: [createStyledAttrsMixin('CSliderFilledTrack')],
  inject: ['$SliderContext'],
  computed: {
    context: function context() {
      return this.$SliderContext();
    },
    componentStyles: function componentStyles() {
      var ref = useSliderStyle(Object.assign({}, this.context, {
        theme: this.theme,
        colorMode: this.colorMode
      }));
      var filledTrackStyle = ref.filledTrackStyle;
      return filledTrackStyle;
    }
  },
  render: function render(h) {
    var ref = this.context;
    var isDisabled = ref.isDisabled;
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        'aria-disabled': isDisabled,
        'data-slider-filled-track': ''
      }),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CSliderThumb component
 *
 * The thumb handler for the slider component
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/slider
 */

var CSliderThumb = {
  name: 'CSliderThumb',
  mixins: [createStyledAttrsMixin('CSliderThumb')],
  inject: ['$SliderContext'],
  computed: {
    context: function context() {
      return this.$SliderContext();
    },
    componentStyles: function componentStyles() {
      var ref = this.context;
      var orientation = ref.orientation;
      var trackPercent = ref.trackPercent;
      var size = ref.size;
      var color = ref.color;
      var ref$1 = useSliderStyle({
        trackPercent: trackPercent,
        orientation: orientation,
        color: color,
        size: size,
        theme: this.theme,
        colorMode: this.colorMode
      });
      var thumbStyle = ref$1.thumbStyle;
      return Object.assign({}, {
        d: 'flex',
        alignItems: 'center',
        outline: 'none',
        justifyContent: 'center'
      }, thumbStyle);
    }
  },
  render: function render(h) {
    var ref = this.context;
    var thumbId = ref.thumbId;
    var isDisabled = ref.isDisabled;
    var onFocus = ref.onFocus;
    var onKeyDown = ref.onThumbKeyDown;
    var min = ref.min;
    var max = ref.max;
    var valueText = ref.valueText;
    var orientation = ref.orientation;
    var value = ref.value;
    var ariaLabelledBy = ref.ariaLabelledBy;
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        id: thumbId,
        role: 'slider',
        tabindex: isDisabled ? undefined : 0,
        'aria-disabled': isDisabled,
        'aria-valuemin': min,
        'aria-valuetext': valueText,
        'aria-orientation': orientation,
        'aria-valuenow': value,
        'aria-valuemax': max,
        'aria-labelledby': ariaLabelledBy
      }),
      on: Object.assign({}, this.computedListeners, {
        keydown: onKeyDown,
        focus: onFocus
      })
    }, this.$slots.default);
  }
};

export default CSlider;
export { CSliderFilledTrack, CSliderThumb, CSliderTrack };
