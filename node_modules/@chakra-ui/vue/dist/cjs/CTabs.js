
/*
 * ! @chakra-ui/vue v0.10.2 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('./index-a67b3d6b.js');
require('./index-1b221f99.js');
require('@emotion/css');
require('vue');
require('./color-mode-observer-fffa3a3b.js');

var baseProps = {
  display: 'flex',
  cursor: 'pointer',
  alignItems: 'center',
  justifyContent: 'center',
  transition: 'all 0.2s',
  _focus: {
    zIndex: '1',
    boxShadow: 'outline'
  }
};
var disabledProps = {
  _disabled: {
    opacity: 0.4,
    cursor: 'not-allowed'
  }
};

var lineStyle = function lineStyle(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var _color = {
    light: color + ".600",
    dark: color + ".300"
  };
  return {
    tabList: {
      borderBottom: '2px',
      borderColor: 'inherit'
    },
    tab: {
      borderBottom: '2px',
      borderColor: 'transparent',
      mb: '-2px',
      _selected: {
        color: _color[colorMode],
        borderColor: 'currentColor'
      },
      _active: {
        bg: 'gray.200'
      },
      _disabled: {
        opacity: 0.4,
        cursor: 'not-allowed'
      }
    }
  };
};

var enclosedStyle = function enclosedStyle(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var theme = ref.theme;
  var _selectedColor = {
    light: color + ".600",
    dark: color + ".300"
  };
  var _selectedBg = {
    light: '#fff',
    dark: theme.colors.gray[800]
  };
  return {
    tab: {
      roundedTop: 'md',
      border: '1px',
      borderColor: 'transparent',
      mb: '-1px',
      _selected: {
        color: _selectedColor[colorMode],
        borderColor: 'inherit',
        borderBottomColor: _selectedBg[colorMode]
      }
    },
    tabList: {
      mb: '-1px',
      borderBottom: '1px',
      borderColor: 'inherit'
    }
  };
};

var enclosedColoredStyle = function enclosedColoredStyle(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var bg = {
    light: 'gray.50',
    dark: 'whiteAlpha.50'
  };
  var _selectedColor = {
    light: color + ".600",
    dark: color + ".300"
  };
  var _selectedBg = {
    light: '#fff',
    dark: 'gray.800'
  };
  return {
    tab: {
      border: '1px',
      borderColor: 'inherit',
      bg: bg[colorMode],
      mb: '-1px',
      _notLast: {
        mr: '-1px'
      },
      _selected: {
        bg: _selectedBg[colorMode],
        color: _selectedColor[colorMode],
        borderColor: 'inherit',
        borderTopColor: 'currentColor',
        borderBottomColor: 'transparent'
      }
    },
    tabList: {
      mb: '-1px',
      borderBottom: '1px',
      borderColor: 'inherit'
    }
  };
};

var softRoundedStyle = function softRoundedStyle(ref) {
  var color = ref.color;
  return {
    tab: {
      rounded: 'full',
      fontWeight: 'semibold',
      color: 'gray.600',
      _selected: {
        color: color + ".700",
        bg: color + ".100"
      }
    },
    tabList: {}
  };
};

var solidRoundedStyle = function solidRoundedStyle(ref) {
  var color = ref.color;
  var colorMode = ref.colorMode;
  var _color = {
    light: 'gray.600',
    dark: 'inherit'
  };
  var _selectedBg = {
    light: color + ".600",
    dark: color + ".300"
  };
  var _selectedColor = {
    light: '#fff',
    dark: 'gray.800'
  };
  return {
    tab: {
      rounded: 'full',
      fontWeight: 'semibold',
      color: _color[colorMode],
      _selected: {
        color: _selectedColor[colorMode],
        bg: _selectedBg[colorMode]
      }
    },
    tabList: {}
  };
};

var variantStyle = function variantStyle(props) {
  switch (props.variant) {
    case 'line':
      return lineStyle(props);

    case 'enclosed':
      return enclosedStyle(props);

    case 'enclosed-colored':
      return enclosedColoredStyle(props);

    case 'soft-rounded':
      return softRoundedStyle(props);

    case 'solid-rounded':
      return solidRoundedStyle(props);

    case 'unstyled':
      return {};
  }
};
var orientationStyle = function orientationStyle(ref) {
  var align = ref.align;
  var orientation = ref.orientation;
  var alignments = {
    end: 'flex-end',
    center: 'center',
    start: 'flex-start'
  };
  var tabListStyle;
  var tabStyle;

  if (orientation === 'horizontal') {
    tabListStyle = {
      alignItems: 'center',
      justifyContent: alignments[align],
      maxWidth: 'full'
    };
    tabStyle = {
      height: '100%'
    };
  }

  if (orientation === 'vertical') {
    tabListStyle = {
      flexDirection: 'column'
    };
    tabStyle = {
      width: '100%'
    };
  }

  return {
    tabList: tabListStyle,
    tab: tabStyle
  };
};
var tabSizes = {
  sm: {
    padding: '0.25rem 1rem',
    fontSize: '0.85rem'
  },
  md: {
    fontSize: '1rem',
    padding: '0.5rem 1rem'
  },
  lg: {
    fontSize: '1.15rem',
    padding: '0.75rem 1rem'
  }
};
/**
 * Creates tab styles
 * @param {{ theme: Object, colorMode: String, variant: String, color: String, size: String, isFitted: Boolean, orientation: String }} props Variant props
 */

var useTabStyle = function useTabStyle(ref) {
  var theme = ref.theme;
  var colorMode = ref.colorMode;
  var variant = ref.variant;
  var color = ref.color;
  var size = ref.size;
  var isFitted = ref.isFitted;
  var orientation = ref.orientation;

  var _variantStyle = variantStyle({
    variant: variant,
    color: color,
    theme: theme,
    colorMode: colorMode
  });

  var _orientationStyle = orientationStyle({
    orientation: orientation
  });

  return Object.assign({}, baseProps, disabledProps, tabSizes[size], _variantStyle && _variantStyle.tab, _orientationStyle && _orientationStyle.tab, isFitted && {
    flex: 1
  });
};
/**
 * Creates TabList styles
 * @param {{ theme: Object, variant: String, align: String, orientation: String }} props Variant props
 */

var useTabListStyle = function useTabListStyle(ref) {
  var theme = ref.theme;
  var variant = ref.variant;
  var align = ref.align;
  var orientation = ref.orientation;

  var _variantStyle = variantStyle({
    variant: variant,
    theme: theme
  });

  var _orientationStyle = orientationStyle({
    align: align,
    orientation: orientation
  });

  return Object.assign({}, _variantStyle && _variantStyle.tabList, _orientationStyle && _orientationStyle.tabList);
};

/**
 * Hey! Welcome to @chakra-ui/vue Tabs
 *
 * The CTab component consists of clickable tabs, that are aligned side by side.
 *
 * @see Docs     https://vue.chakra-ui.com/tabs
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CTabs/CTabs.js
 */
/**
 * CTabs component
 *
 * the switch component that serves as an alternative for checkbox.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTabs = {
  name: 'CTabs',
  mixins: [utils.createStyledAttrsMixin('CTabs')],
  props: {
    index: Number,
    defaultIndex: Number,
    isManual: Boolean,
    variant: {
      type: String,
      default: 'line'
    },
    variantColor: {
      type: String,
      default: 'blue'
    },
    align: {
      type: String,
      default: 'start'
    },
    size: {
      type: String,
      default: 'md'
    },
    orientation: {
      type: String,
      default: 'horizontal'
    },
    isFitted: Boolean
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $TabContext: function $TabContext() {
        return this$1.TabContext;
      }
    };
  },
  data: function data() {
    return {
      selectedPanelNode: undefined,
      selectedIndex: this.getInitialIndex(),
      manualIndex: this.index || this.defaultIndex || 0
    };
  },
  computed: {
    TabContext: function TabContext() {
      return {
        id: this.id,
        selectedIndex: this.selectedIndex,
        index: this.actualIdx,
        manualIndex: this.manualIdx,
        onManualTabChange: this.onManualTabChange,
        isManual: this.isManual,
        onChangeTab: this.onChangeTab,
        selectedPanelRef: this.selectedPanelRef,
        onFocusPanel: this.onFocusPanel,
        color: this.variantColor,
        size: this.size,
        align: this.align,
        variant: this.variant,
        isFitted: this.isFitted,
        orientation: this.orientation,
        set: this.set
      };
    },
    isControlled: function isControlled() {
      return utils.isDef(this.index);
    },
    id: function id() {
      return "tabs-" + utils.useId();
    },
    actualIdx: function actualIdx() {
      if (!this.isManual) {
        return this.defaultIndex || 0;
      } else {
        return this.index || this.defaultIndex || 0;
      }
    },
    manualIdx: function manualIdx() {
      return this.isControlled ? this.index : this.manualIndex;
    }
  },
  created: function created() {
    utils.useVariantColorWarning(this.theme, 'CTabs', this.variantColor);
  },
  methods: {
    /**
     * Gets initial active tab index
     */
    getInitialIndex: function getInitialIndex() {
      if (!this.isManual) {
        return this.defaultIndex || 0;
      } else {
        return this.index || this.defaultIndex || 0;
      }
    },

    /**
     * Handles tab chage
     * @param {Number} index Index to vbe set
     */
    onChangeTab: function onChangeTab(index) {
      if (!this.isControlled) {
        this.selectedIndex = index;
      }

      if (this.isControlled && this.isManual) {
        this.selectedIndex = index;
      }

      if (!this.isManual) {
        this.$emit('change', index);
      }
    },

    /**
     * Manual tab change handler
     * @param {Number} index Index of tab to set
     */
    onManualTabChange: function onManualTabChange(index) {
      if (!this.isControlled) {
        this.manualIndex = index;
      }

      if (this.isManual) {
        this.$emit('change', index);
      }
    },

    /**
     * Focuses on active tab
     */
    onFocusPanel: function onFocusPanel() {
      if (this.selectedPanelNode) {
        this.selectedPanelNode.focus();
      }
    },

    /**
     * Sets the value of any component instance property.
     * This function is to be passed down to context so that consumers
     * can mutate context values with out doing it directly.
     * Serves as a temporary fix until Vue 3 comes out
     * @param {String} prop Component instance property
     * @param {Any} value Property value
     */
    set: function set(prop, value) {
      this[prop] = value;
      return this[prop];
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CTabList component
 *
 * the list wrapper component for each tab
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTabList = {
  name: 'CTabList',
  mixins: [utils.createStyledAttrsMixin('CTabList')],
  inject: ['$TabContext'],
  data: function data() {
    return {
      allNodes: {},
      validChildren: [],
      focusableIndexes: []
    };
  },
  computed: {
    context: function context() {
      return this.$TabContext();
    },
    componentStyles: function componentStyles() {
      var ref = this.context;
      var align = ref.align;
      var variant = ref.variant;
      var orientation = ref.orientation;
      return Object.assign({}, {
        display: 'flex'
      }, useTabListStyle({
        theme: this.theme,
        align: align,
        orientation: orientation,
        variant: variant
      }));
    },
    enabledSelectedIndex: function enabledSelectedIndex() {
      var ref = this.context;
      var selectedIndex = ref.selectedIndex;
      return this.focusableIndexes.indexOf(selectedIndex);
    },
    count: function count() {
      return this.focusableIndexes.length;
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$nextTick(function () {
      var children = this$1.$el.children;
      this$1.allNodes = Object.assign({}, children);
    });
  },
  methods: {
    /**
     * Updates current Index
     * @param {Number} index Index
     */
    updateIndex: function updateIndex(index) {
      var ref = this.context;
      var onChangeTab = ref.onChangeTab;
      var childIndex = this.focusableIndexes[index];
      this.allNodes[childIndex].focus();
      onChangeTab && onChangeTab(childIndex);
    },

    /**
     * Handles keydown event
     * @param {Event} event event
     */
    handleKeyDown: function handleKeyDown(event) {
      var ref = this.context;
      var onFocusPanel = ref.onFocusPanel;

      if (event.key === 'ArrowRight') {
        event.preventDefault();
        var nextIndex = (this.enabledSelectedIndex + 1) % this.count;
        this.updateIndex(nextIndex);
      }

      if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
        event.preventDefault();
        var nextIndex$1 = (this.enabledSelectedIndex - 1 + this.count) % this.count;
        this.updateIndex(nextIndex$1);
      }

      if (event.key === 'Home') {
        event.preventDefault();
        this.updateIndex(0);
      }

      if (event.key === 'End') {
        event.preventDefault();
        this.updateIndex(this.count - 1);
      }

      if (event.key === 'ArrowDown') {
        event.preventDefault();
        onFocusPanel && onFocusPanel();
      }

      this.$emit('keydown', event);
    }
  },
  render: function render(h) {
    var this$1 = this;
    this.validChildren = utils.cleanChildren(this.$slots.default);
    var ref = this.context;
    var id = ref.id;
    var isManual = ref.isManual;
    var manualIndex = ref.manualIndex;
    var selectedIndex = ref.selectedIndex;
    var onManualTabChange = ref.onManualTabChange;
    var onChangeTab = ref.onChangeTab;
    var orientation = ref.orientation;
    var validChildren = utils.cleanChildren(this.$slots.default);
    var clones = validChildren.map(function (vnode, index) {
      var isSelected = isManual ? index === manualIndex : index === selectedIndex;

      var handleClick = function handleClick(event) {
        // Hack for Safari. Buttons don't receive focus on click on Safari
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
        this$1.allNodes[index].focus();
        onManualTabChange(index);
        onChangeTab(index);
        this$1.$emit('click', event);
      };

      var clone = utils.cloneVNodeElement(vnode, {
        props: {
          isSelected: isSelected
        },
        nativeOn: {
          click: handleClick
        },
        attrs: {
          id: id + "-" + index
        }
      }, h);
      return clone;
    });
    this.focusableIndexes = clones.map(function (child, index) {
      return child.componentOptions.propsData.isDisabled === true ? null : index;
    }).filter(function (index) {
      return index != null;
    });
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        role: 'tablist',
        'aria-orientation': orientation
      }, this.computedAttrs),
      on: Object.assign({}, this.computedListeners, {
        keydown: this.handleKeyDown
      })
    }, clones);
  }
};
/**
 * CTab component
 *
 * the tab element component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTab = {
  name: 'CTab',
  mixins: [utils.createStyledAttrsMixin('CTab')],
  inject: ['$TabContext'],
  props: {
    isSelected: Boolean,
    isDisabled: Boolean,
    id: String,
    as: {
      type: [String, Object],
      default: 'button'
    }
  },
  computed: {
    context: function context() {
      return this.$TabContext();
    },
    componentStyles: function componentStyles() {
      var ref = this.context;
      var color = ref.color;
      var isFitted = ref.isFitted;
      var orientation = ref.orientation;
      var size = ref.size;
      var variant = ref.variant;
      return Object.assign({}, {
        outline: 'none'
      }, useTabStyle({
        colorMode: this.colorMode,
        theme: this.theme,
        color: color,
        isFitted: isFitted,
        orientation: orientation,
        size: size,
        variant: variant
      }));
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        role: 'tab',
        tabindex: this.isSelected ? 0 : -1,
        id: "tab:" + this.id,
        type: 'button',
        disabled: this.isDisabled,
        'aria-disabled': this.isDisabled,
        'aria-selected': this.isSelected,
        'aria-controls': "panel:" + this.id
      }, this.computedAttrs),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CTabPanel component
 *
 * the panel element component fro tab content
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTabPanel = {
  name: 'CTabPanel',
  mixins: [utils.createStyledAttrsMixin('CTabPanel')],
  props: {
    isSelected: Boolean,
    selectedPanelNode: Object,
    id: String
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        role: 'tabpanel',
        tabindex: -1,
        'aria-labelledby': "tab:" + this.id,
        hidden: !this.isSelected,
        id: "panel:" + this.id,
        outline: 0
      }, this.computedAttrs),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CTabPanels component
 *
 * the wrapper  component fro tab panels
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/tabs
 */

var CTabPanels = {
  name: 'CTabPanels',
  mixins: [utils.createStyledAttrsMixin('CTabPanels')],
  inject: ['$TabContext'],
  computed: {
    context: function context() {
      return this.$TabContext();
    }
  },
  render: function render(h) {
    var ref = this.context;
    var selectedIndex = ref.selectedIndex;
    var id = ref.id;
    var isManual = ref.isManual;
    var manualIndex = ref.manualIndex;
    var validChildren = utils.cleanChildren(this.$slots.default);
    var clones = validChildren.map(function (child, index) {
      var isSelected = isManual ? index === manualIndex : index === selectedIndex;
      return utils.cloneVNodeElement(child, {
        props: {
          isSelected: isSelected,
          id: id + "-" + index
        }
      }, h);
    });
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        tabindex: -1
      }, this.computedAttrs),
      on: this.computedListeners
    }, clones);
  }
};

exports.CTab = CTab;
exports.CTabList = CTabList;
exports.CTabPanel = CTabPanel;
exports.CTabPanels = CTabPanels;
exports.CTabs = CTabs;
