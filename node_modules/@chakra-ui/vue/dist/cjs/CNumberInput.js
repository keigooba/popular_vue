
/*
 * ! @chakra-ui/vue v0.10.2 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('./index-a67b3d6b.js');
require('./index-1b221f99.js');
require('./internal-icons-71685dde.js');
require('@emotion/css');
require('vue');
require('./color-mode-observer-fffa3a3b.js');
var CIcon = require('./index-6e5c2a28.js');
var CPseudoBox = require('./CPseudoBox.js');
require('./props.types-b9d2d3c4.js');
var CFlex = require('./index-eb2552c9.js');
require('./input.styles-2ea30c29.js');
var CInput = require('./index-857bd463.js');

function isNumberKey(event) {
  var charCode = event.which ? event.which : event.keyCode;

  if (event.key === '.') {
    return true;
  }

  if (charCode > 31 && (charCode < 48 || charCode > 57) && (charCode < 96 || charCode > 105) && charCode !== 110) {
    return false;
  }

  return true;
}
function preventNonNumberKey(event) {
  if (!isNumberKey(event)) {
    event.preventDefault();
  }
}
function roundToPrecision(value, precision) {
  return value === '' ? parseFloat(0).toFixed(precision) : parseFloat(value).toFixed(precision);
}
/**
 * Calculates the precision of a value
 * @param {Number} value Value
 */

function calculatePrecision(value) {
  var groups = /[1-9]([0]+$)|\.([0-9]*)/.exec(String(value));

  if (!groups) {
    return 0;
  }

  if (groups[1]) {
    return -groups[1].length;
  }

  if (groups[2]) {
    return groups[2].length;
  }

  return 0;
}

var themedProps = {
  light: {
    borderColor: 'inherit',
    _active: {
      bg: 'gray.200'
    }
  },
  dark: {
    color: 'whiteAlpha.800',
    borderColor: 'whiteAlpha.300',
    _active: {
      bg: 'whiteAlpha.300'
    }
  }
};

var styleProps = function styleProps(ref) {
  var colorMode = ref.colorMode;
  var size = ref.size;
  return Object.assign({}, {
    borderLeft: '1px',
    _first: {
      roundedTopRight: size === 'sm' ? 1 : 3
    },
    _last: {
      roundedBottomRight: size === 'sm' ? 1 : 3,
      mt: '-1px',
      borderTopWidth: 1
    },
    _disabled: {
      opacity: 0.4,
      cursor: 'not-allowed'
    }
  }, themedProps[colorMode]);
};

/**
 * Hey! Welcome to @chakra-ui/vue Number Input
 *
 * The `CNumberInput` component is similar to the `CInput` component,
 * but it has controls for incrementing or decrementing numeric values.
 *
 * @see Docs     https://vue.chakra-ui.com/numberinput
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CNumberInput/CNumberInput.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CNumberInput/accessibility.md
 */
function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CNumberInput component
 *
 * The wrapper that provides context and logic to the components
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/numberinput
 */

var CNumberInput = {
  name: 'CNumberInput',
  inheritAttrs: false,
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    value: [Number, String],
    defaultValue: Number,
    focusInputOnChange: {
      type: Boolean,
      default: true
    },
    clampValueOnBlur: {
      type: Boolean,
      default: true
    },
    keepWithinRange: {
      type: Boolean,
      default: true
    },
    min: {
      type: Number,
      default: -Infinity
    },
    max: {
      type: Number,
      default: Infinity
    },
    step: {
      type: Number,
      default: 1
    },
    precision: Number,
    getAriaValueText: Function,
    isReadOnly: Boolean,
    isInvalid: Boolean,
    isDisabled: Boolean,
    isFullWidth: Boolean,
    size: {
      type: String,
      default: 'md'
    },
    inputId: {
      type: String
    }
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $NumberInputContext: function $NumberInputContext() {
        return this$1.NumberInputContext;
      }
    };
  },
  data: function data() {
    return {
      innerValue: this.defaultValue || null,
      isFocused: false,
      prevNexValue: null,
      inputNode: undefined,
      incrementPressed: false,
      decrementPressed: false,
      incrementEvents: {},
      decrementEvents: {},
      clickEvent: utils.canUseDOM && !!document.documentElement.ontouchstart ? 'touchstart' : 'mousedown',
      incrementStepperProps: undefined,
      decrementStepperProps: undefined,
      incrementTimerId: null,
      decrementTimerId: null
    };
  },
  computed: {
    NumberInputContext: function NumberInputContext() {
      var this$1 = this;
      return {
        size: this.size,
        value: this._value,
        isReadOnly: this.isReadOnly,
        isInvalid: this.isInvalid,
        isDisabled: this.isDisabled,
        isFocused: this.isFocused,
        incrementStepper: this.incrementStepperProps,
        decrementStepper: this.decrementStepperProps,
        incrementButton: {
          nativeOn: {
            click: function click() {
              return this$1.handleIncrement();
            }
          },
          attrs: Object.assign({}, {
            'aria-label': 'add'
          }, this.keepWithinRange & {
            disabled: this.value === this.max,
            'aria-disabled': this.value === this.max
          })
        },
        decrementButton: {
          nativeOn: {
            click: function click() {
              return this$1.handleDecrement();
            }
          },
          attrs: Object.assign({}, {
            'aria-label': 'subtract'
          }, this.keepWithinRange & {
            disabled: this.value === this.min,
            'aria-disabled': this.value === this.min
          })
        },
        input: Object.assign({}, {
          value: this._value,
          onChange: this.handleChange,
          onKeydown: this.handleKeydown,
          onFocus: function onFocus() {
            this$1.isFocused = true;
          },
          onBlur: function onBlur() {
            this$1.isFocused = false;

            if (this$1.clampValueOnBlur) {
              this$1.validateAndClamp();
            }
          },
          role: 'spinbutton',
          type: 'text',
          'aria-valuemin': this.min,
          'aria-valuemax': this.max,
          'aria-disabled': this.isDisabled,
          'aria-valuenow': this.value,
          'aria-invalid': this.isInvalid || this.isOutOfRange
        }, this.getAriaValueText && {
          'aria-valuetext': this.ariaValueText
        }, {
          readOnly: this.isReadOnly,
          disabled: this.isDisabled,
          autoComplete: 'off'
        }),
        hiddenLabel: {
          'aria-live': 'polite',
          text: this.getAriaValueText ? this.ariaValueText : this._value,
          style: {
            position: 'absolute',
            clip: 'rect(0px, 0px, 0px, 0px)',
            height: 1,
            width: 1,
            margin: -1,
            whiteSpace: 'nowrap',
            border: 0,
            overflow: 'hidden',
            padding: 0
          }
        },
        inputId: this._inputId
      };
    },
    isControlled: function isControlled() {
      return utils.isDef(this.value);
    },
    _value: {
      get: function get() {
        return this.isControlled ? roundToPrecision(this.value, this._precision) : this.innerValue ? roundToPrecision(this.innerValue, this._precision) : this.innerValue;
      },
      set: function set(val) {
        if (!this.defaultValue) {
          var nextValue = this.defaultValue;

          if (this.keepWithinRange) {
            nextValue = Math.max(Math.min(nextValue, this.max), this.min);
          }

          nextValue = roundToPrecision(nextValue, this._precision);
          this.innerValue = nextValue;
        }

        this.innerValue = val;
      }
    },
    defaultPrecision: function defaultPrecision() {
      return Math.max(calculatePrecision(this.step), 0);
    },
    _precision: function _precision() {
      return this.precision || this.defaultPrecision;
    },
    isInteractive: function isInteractive() {
      return !(this.isReadOnly || this.isDisabled);
    },
    isOutOfRange: function isOutOfRange() {
      return this._value > this.max || this.value < this.min;
    },
    ariaValueText: function ariaValueText() {
      return this.getAriaValueText ? this.getAriaValueText(this._value) : null;
    },
    _inputId: function _inputId() {
      return "number-input-" + (this.inputId || utils.useId());
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    var obj, obj$1;
    this.$nextTick(function () {
      this$1.inputNode = utils.getElement("#" + this$1._inputId, this$1.$el);
    }); // ================================= INCREMENT WATCHER

    this.$watch(function (vm) {
      return [vm.incrementPressed, vm._value];
    }, function () {
      if (this$1.incrementTimerId) {
        clearTimeout(this$1.incrementTimerId);
      }

      if (this$1.incrementPressed) {
        this$1.incrementTimerId = setTimeout(this$1.handleIncrement, 200);
      } else {
        clearTimeout(this$1.incrementTimerId);
      }
    });

    var startIncrement = function startIncrement() {
      this$1.handleIncrement();
      this$1.incrementPressed = true;
    };

    var stopIncrement = function stopIncrement() {
      this$1.incrementPressed = false;
    };

    this.incrementStepperProps = (obj = {}, obj[this.clickEvent] = startIncrement, obj.mouseup = stopIncrement, obj.mouseleave = stopIncrement, obj.touchend = stopIncrement, obj); // ================================= DECREMENT WATCHER

    this.$watch(function (vm) {
      return [vm.decrementPressed, vm._value];
    }, function () {
      if (this$1.decrementTimerId) {
        clearTimeout(this$1.decrementTimerId);
      }

      if (this$1.decrementPressed) {
        this$1.decrementTimerId = setTimeout(this$1.handleDecrement, 200);
      } else {
        clearTimeout(this$1.decrementTimerId);
      }
    });

    var startDecrement = function startDecrement() {
      this$1.handleDecrement();
      this$1.decrementPressed = true;
    };

    var stopDecrement = function stopDecrement() {
      this$1.decrementPressed = false;
    };

    this.decrementStepperProps = (obj$1 = {}, obj$1[this.clickEvent] = startDecrement, obj$1.mouseup = stopDecrement, obj$1.mouseleave = stopDecrement, obj$1.touchend = stopDecrement, obj$1);
  },
  methods: {
    /**
     * Validates and clamps input values
     */
    validateAndClamp: function validateAndClamp() {
      var maxExists = utils.isDef(this.max);
      var minExists = utils.isDef(this.min);

      if (maxExists && this._value > this.max) {
        this.updateValue(this.max);
      }

      if (minExists && this._value < this.min) {
        this.updateValue(this.min);
      }
    },

    /**
     * Get increment factor
     */
    getIncrementFactor: function getIncrementFactor(event) {
      var ratio = 1;

      if (event.metaKey || event.ctrlKey) {
        ratio = 0.1;
      }

      if (event.shiftKey) {
        ratio = 10;
      }

      return ratio;
    },

    /**
     * Determines whether a value should be converted to number
     * @param {String} value
     */
    shouldConvertToNumber: function shouldConvertToNumber(value) {
      var _value = typeof value !== 'string' ? String(value) : value;

      var hasDot = _value.includes('.');

      var hasTrailingZero = _value.substr(_value.length - 1) === '0';
      var hasTrailingDot = _value.substr(_value.length - 1) === '.';

      if (hasDot && hasTrailingZero) {
        return false;
      }

      if (hasDot && hasTrailingDot) {
        return false;
      }

      return true;
    },

    /**
     * Updates the current input value
     * @param {Number|String} nextValue value
     */
    updateValue: function updateValue(nextValue) {
      if (this.prevNextValue === nextValue) {
        return;
      }

      var shouldConvert = this.shouldConvertToNumber(nextValue);
      var converted = shouldConvert ? +nextValue : nextValue;

      if (!this.isControlled) {
        this._value = converted;
      }

      this.$emit('change', converted);
      this.prevNextValue = nextValue;
    },

    /**
     * Handles value increment
     * @param {Number} step Value to be incremented
     */
    handleIncrement: function handleIncrement(step) {
      if (step === void 0) step = this.step;

      if (!this.isInteractive) {
        return;
      }

      var nextValue = Number(this._value) + Number(step);

      if (this.keepWithinRange) {
        nextValue = Math.min(nextValue, this.max);
      }

      nextValue = roundToPrecision(nextValue, this._precision);
      this.updateValue(nextValue);
      this.$emit('increment', nextValue);
      this.focusInput();
    },

    /**
     * Handles value decrement
     * @param {Number} step Value to be decremented
     */
    handleDecrement: function handleDecrement(step) {
      if (step === void 0) step = this.step;

      if (!this.isInteractive) {
        return;
      }

      var nextValue = Number(this._value) - Number(step);

      if (this.keepWithinRange) {
        nextValue = Math.max(nextValue, this.min);
      }

      nextValue = roundToPrecision(nextValue, this._precision);
      this.updateValue(nextValue);
      this.$emit('decrement', nextValue);
      this.focusInput();
    },

    /**
     * Focus NumberInput element
     */
    focusInput: function focusInput() {
      var _this = this;

      requestAnimationFrame(function () {
        _this.inputNode && _this.inputNode.focus();
      });
    },

    /**
     * Handles "blur" event
     * @param {Event} event Event object
     */
    handleBlur: function handleBlur(event) {
      this.$emit('blur', event);
    },

    /**
     * Handles "focus" event
     * @param {Event} event Event object
     */
    handleFocus: function handleFocus(event) {
      this.$emit('focus', event);
    },

    /**
     * Handles "keydown" event
     * @param {Event} event Event object
     */
    handleKeydown: function handleKeydown(event) {
      this.$emit('keydown', event);
      preventNonNumberKey(event);

      if (!this.isInteractive) {
        return;
      }

      if (event.key === 'ArrowUp') {
        event.preventDefault();
        var ratio = this.getIncrementFactor(event);
        this.handleIncrement(ratio * this.step);
      }

      if (event.key === 'ArrowDown') {
        event.preventDefault();
        var ratio$1 = this.getIncrementFactor(event);
        this.handleDecrement(ratio$1 * this.step);
      }

      if (event.key === 'Home') {
        event.preventDefault();

        if (utils.isDef(this.min)) {
          this.updateValue(this.max);
        }
      }

      if (event.key === 'End') {
        event.preventDefault();

        if (utils.isDef(this.max)) {
          this.updateValue(this.min);
        }
      }
    },

    /**
     *
     * @param {Event} event Event object
     * @param {Any} event Value
     */
    handleChange: function handleChange(event, _value) {
      var finalValue;
      var ref = event.target;
      var value = ref.value;

      if (['', undefined].includes(value)) {
        finalValue = 0;
      }

      finalValue = value;
      this.updateValue(finalValue);
      this.$emit('change', finalValue, event);
    }
  },
  render: function render(h) {
    var ref = this.$props;
    var size = ref.size;
    var rest = objectWithoutProperties(ref, ["size"]);
    var styles = rest;
    return h(CFlex.CFlex, {
      props: {
        align: 'stretch'
      },
      attrs: Object.assign({}, styles, {
        w: this.isFullWidth ? 'full' : null,
        pos: 'relative',
        'data-chakra-component': 'CNumberInput'
      })
    }, this.$slots.default);
  }
};
/**
 * CNumberInputField component
 *
 * The `input` field itself
 *
 * @extends CInput
 * @see Docs https://vue.chakra-ui.com/numberinput
 */

var CNumberInputField = {
  name: 'CNumberInputField',
  inheritAttrs: false,
  inject: ['$NumberInputContext'],
  computed: {
    context: function context() {
      return this.$NumberInputContext();
    }
  },
  props: CInput.inputProps,
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var size = ref.size;
    var inputId = ref.inputId;
    var ref_input = ref.input;
    var value = ref_input.value;
    var _onBlur = ref_input.onBlur;
    var _onFocus = ref_input.onFocus;
    var _onChange = ref_input.onChange;
    var _onKeydown = ref_input.onKeydown;
    var isDisabled = ref_input.disabled;
    var isReadOnly = ref_input.readOnly;
    var rest = objectWithoutProperties(ref_input, ["value", "onBlur", "onFocus", "onChange", "onKeydown", "disabled", "readOnly"]);
    var otherInputAttrs = rest;
    return h(CInput.CInput, {
      props: Object.assign({}, this.$props, {
        isReadOnly: isReadOnly,
        isDisabled: isDisabled,
        size: size,
        value: value
      }),
      attrs: Object.assign({}, this.$attrs, {
        id: inputId
      }, otherInputAttrs, {
        'data-chakra-component': 'CNumberInputField'
      }),
      on: {
        change: utils.wrapEvent(function (e) {
          return this$1.$emit('change', e);
        }, _onChange)
      },
      nativeOn: {
        input: utils.wrapEvent(function (e) {
          return this$1.$emit('change', e);
        }, _onChange),
        blur: utils.wrapEvent(function (e) {
          return this$1.$emit('blur', e);
        }, _onBlur),
        focus: utils.wrapEvent(function (e) {
          return this$1.$emit('focus', e);
        }, _onFocus),
        keydown: utils.wrapEvent(function (e) {
          return this$1.$emit('keydown', e);
        }, _onKeydown)
      }
    });
  }
};
/**
 * CNumberInputStepper component
 *
 * The wrapper for the input's stepper buttons.
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/numberinput
 */

var CNumberInputStepper = {
  name: 'CNumberInputStepper',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var slots = ref.slots;
    var rest$1 = objectWithoutProperties(ref, ["data", "slots"]);
    var rest = rest$1;
    return h(CFlex.CFlex, Object.assign({}, rest, {
      props: {
        direction: 'column'
      },
      attrs: {
        width: '24px',
        margin: '1px',
        position: 'absolute',
        right: '0px',
        height: 'calc(100% - 2px)',
        zIndex: 1,
        'data-chakra-component': 'CNumberInputStepper'
      }
    }), slots().default);
  }
};
/**
 * CStepperButton component
 *
 * The composable element for the stepper buttons.
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/numberinput
 */

var CStepperButton = {
  name: 'CStepperButton',
  inheritAttrs: false,
  inject: ['$NumberInputContext', '$chakraColorMode'],
  computed: {
    context: function context() {
      return this.$NumberInputContext();
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    }
  },
  render: function render(h) {
    var ref = this.context;
    var isDisabled = ref.isDisabled;
    var size = ref.size;
    return h(CPseudoBox.default, {
      attrs: Object.assign({}, this.$attrs, {
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        flex: 1,
        transition: 'all 0.3s',
        userSelect: 'none',
        pointerEvents: isDisabled ? 'none' : undefined,
        lineHeight: 'normal'
      }, styleProps({
        colorMode: this.colorMode,
        size: size
      }), {
        'data-chakra-component': 'CStepperButton'
      })
    }, this.$slots.default);
  }
};
/**
 * CNumberIncrementStepper component
 *
 * The button to increment the value of the input.
 *
 * @extends CStepperButton
 * @see Docs https://vue.chakra-ui.com/numberinput
 */

var CNumberIncrementStepper = {
  name: 'CNumberIncrementStepper',
  inheritAttrs: false,
  inject: ['$NumberInputContext'],
  computed: {
    context: function context() {
      return this.$NumberInputContext();
    }
  },
  render: function render(h) {
    var children = this.$slots.default || [h(CIcon.CIcon, {
      props: {
        name: 'triangle-up'
      },
      attrs: {
        height: '0.6em',
        width: '0.6em'
      }
    })];
    var ref = this.context;
    var size = ref.size;
    var incrementStepper = ref.incrementStepper;
    var iconSize = size === 'sm' ? '11px' : '15px';
    return h(CStepperButton, {
      attrs: Object.assign({}, this.$attrs, {
        fontSize: iconSize,
        'data-chakra-component': 'CNumberIncrementStepper'
      }),
      nativeOn: incrementStepper
    }, children);
  }
};
/**
 * CNumberIncrementStepper component
 *
 * The button to decrement the value of the input.
 *
 * @extends CStepperButton
 * @see Docs https://vue.chakra-ui.com/numberinput
 */

var CNumberDecrementStepper = {
  name: 'CNumberDecrementStepper',
  inheritAttrs: false,
  inject: ['$NumberInputContext'],
  computed: {
    context: function context() {
      return this.$NumberInputContext();
    }
  },
  render: function render(h) {
    var children = this.$slots.default || [h(CIcon.CIcon, {
      props: {
        name: 'triangle-down'
      },
      attrs: {
        height: '0.6em',
        width: '0.6em'
      }
    })];
    var ref = this.context;
    var size = ref.size;
    var decrementStepper = ref.decrementStepper;
    var iconSize = size === 'sm' ? '11px' : '15px';
    return h(CStepperButton, {
      attrs: Object.assign({}, this.$attrs, {
        fontSize: iconSize,
        'data-chakra-component': 'CNumberDecrementStepper'
      }),
      nativeOn: decrementStepper
    }, children);
  }
};

exports.CNumberDecrementStepper = CNumberDecrementStepper;
exports.CNumberIncrementStepper = CNumberIncrementStepper;
exports.CNumberInput = CNumberInput;
exports.CNumberInputField = CNumberInputField;
exports.CNumberInputStepper = CNumberInputStepper;
